// Generated by purs version 0.11.7
"use strict";
var $foreign = require("./foreign");
var Data_Boolean = require("../Data.Boolean");
var Data_CommutativeRing = require("../Data.CommutativeRing");
var Data_Eq = require("../Data.Eq");
var Data_EuclideanRing = require("../Data.EuclideanRing");
var Data_Function = require("../Data.Function");
var Data_Maybe = require("../Data.Maybe");
var Data_Ord = require("../Data.Ord");
var Data_Ordering = require("../Data.Ordering");
var Data_Ring = require("../Data.Ring");
var Data_Semigroup = require("../Data.Semigroup");
var Data_Semiring = require("../Data.Semiring");
var Data_Show = require("../Data.Show");
var Prelude = require("../Prelude");
var showDecimal = new Data_Show.Show(function (x) {
    return "(fromString \"" + ($foreign.toString(x) + "\")");
});
var semiringDecimal = new Data_Semiring.Semiring($foreign.dAdd, $foreign.dMul, $foreign.fromInt(1), $foreign.fromInt(0));
var ringDecimal = new Data_Ring.Ring(function () {
    return semiringDecimal;
}, $foreign.dSub);
var fromString = $foreign["fromString'"](Data_Maybe.Nothing.value)(Data_Maybe.Just.create);
var eqDecimal = new Data_Eq.Eq($foreign.dEquals);
var ordDecimal = new Data_Ord.Ord(function () {
    return eqDecimal;
}, function (x) {
    return function (y) {
        var v = $foreign.dCompare(x)(y);
        if (v === 1) {
            return Data_Ordering.GT.value;
        };
        if (v === 0) {
            return Data_Ordering.EQ.value;
        };
        return Data_Ordering.LT.value;
    };
});
var commutativeRingDecimal = new Data_CommutativeRing.CommutativeRing(function () {
    return ringDecimal;
});
var euclideanRingDecimal = new Data_EuclideanRing.EuclideanRing(function () {
    return commutativeRingDecimal;
}, function (v) {
    return 1;
}, $foreign.dDiv, function (v) {
    return function (v1) {
        return Data_Semiring.zero(semiringDecimal);
    };
});
var factorial = function (n) {
    if (Data_Ord.lessThan(ordDecimal)(n)(Data_Semiring.zero(semiringDecimal))) {
        return Data_EuclideanRing.div(euclideanRingDecimal)(Data_Semiring.one(semiringDecimal))(Data_Semiring.zero(semiringDecimal));
    };
    if (Data_Boolean.otherwise) {
        return $foreign.gamma($foreign.ceil(Data_Semiring.add(semiringDecimal)(n)(Data_Semiring.one(semiringDecimal))));
    };
    throw new Error("Failed pattern match at Data.Decimal line 227, column 1 - line 227, column 30: " + [ n.constructor.name ]);
};
module.exports = {
    fromString: fromString,
    factorial: factorial,
    eqDecimal: eqDecimal,
    ordDecimal: ordDecimal,
    showDecimal: showDecimal,
    semiringDecimal: semiringDecimal,
    ringDecimal: ringDecimal,
    commutativeRingDecimal: commutativeRingDecimal,
    euclideanRingDecimal: euclideanRingDecimal,
    fromInt: $foreign.fromInt,
    fromNumber: $foreign.fromNumber,
    toNumber: $foreign.toNumber,
    toString: $foreign.toString,
    toPrecision: $foreign.toPrecision,
    toFixed: $foreign.toFixed,
    "isFinite": $foreign["isFinite"],
    isInteger: $foreign.isInteger,
    toSignificantDigits: $foreign.toSignificantDigits,
    abs: $foreign.abs,
    acos: $foreign.acos,
    acosh: $foreign.acosh,
    asin: $foreign.asin,
    asinh: $foreign.asinh,
    atan: $foreign.atan,
    atan2: $foreign.atan2,
    atanh: $foreign.atanh,
    ceil: $foreign.ceil,
    cos: $foreign.cos,
    cosh: $foreign.cosh,
    exp: $foreign.exp,
    floor: $foreign.floor,
    ln: $foreign.ln,
    log2: $foreign.log2,
    log10: $foreign.log10,
    max: $foreign.max,
    min: $foreign.min,
    modulo: $foreign.modulo,
    pow: $foreign.pow,
    round: $foreign.round,
    sin: $foreign.sin,
    sinh: $foreign.sinh,
    sqrt: $foreign.sqrt,
    tan: $foreign.tan,
    tanh: $foreign.tanh,
    e: $foreign.e,
    pi: $foreign.pi,
    gamma: $foreign.gamma
};
